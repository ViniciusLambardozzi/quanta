; const definitions
li $0, 0  ; const 0
li $1, 1  ; const 1

; convention register definition
li $27, 0 ; arg0
li $28, 0 ; arg1
li $29, 0 ; return
li $30, 0 ; return address

; set the stack pointer to a RAM address
li $5, 512 ; stack pointer

; set IO address registers
li $2, 1  ; hex displays
li $3, 3  ; buttons
li $4, 3  ; switches

; address of the hex displays has the most significant bit set
li $27, 31
.shiftAddress:
    lsl $2
    sub $27, $1
    jne $27, $0, shiftAddress

; address of buttons and switches has the 2 most significant bits set
li $27, 30
.shiftInputAddress:
    lsl $3
    lsl $4
    sub $27, $1
    jne $27, $0, shiftInputAddress

; address of switches also has the least significant bit set
or $4, $1

; main routine
.main:
    ; wait for user input
    call getInput
    store $29, $5

    call waitRelease

    ; wait for user input
    call getInput
    mov $27, $29

    ; load first value from stack
    load $28, $5

    call multiply

    ; get the result of the multiplication,and print it
    mov $27, $29
    call printHex

    j end

; wait for a button press, then return the switches
.getInput:
    load $6, $3
    li $7, 14

    load $27, $4

    ; store return address in stack before subroutine call
    add $5, $1
    store $30, $5
    call printHex
    load $30, $5
    sub $5, $1

    jne $6, $7, getInput

    mov $29, $27
    j $30

; output arg0 to hex displays
.printHex:
    store $27, $2
    j $30

; wait until the button has been released
.waitRelease:
    load $6, $3
    li $7, 15
    jeq $6, $7, $30
    j waitRelease

; multiply arg0 by arg1
.multiply:
    ; save a copy of arg1 as iterator
    mov $26, $28
    ; initialize return value as 0
    mov $29, 0

    .multiplyLoop:
        ; return if multiplying by 0
        jeq $26, $0, $30
        ; consecutive sum
        add $29, $27
        sub $26, $1
        j multiplyLoop


; infinite loop to stall execution
.end:
    j end